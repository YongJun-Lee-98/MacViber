# WinViber Development Guide (Tauri, Rust, React)

A guide to building a cross-platform terminal application inspired by MacViber, using Tauri, Rust, and React.

---

## Step 1: Initial Project Setup

```
Create a new Tauri application with a React frontend.
- Use `create-tauri-app` with the `react-ts` template.
- Set up the project structure for a scalable application.
- Add necessary Rust crates:
  - `serde`, `serde_json` for data serialization.
  - `tokio` for asynchronous operations.
  - `tauri-plugin-pty` or a custom implementation for pseudo-terminal management.
  - `shlex` for shell argument parsing.
- Add necessary npm packages:
  - `xterm`, `xterm-react` for the terminal UI.
  - `xterm-addon-fit`, `xterm-addon-unicode11`, etc.
  - A state management library like `zustand` or `react-redux`.
  - A Markdown rendering library like `react-markdown`.
```

### Estimated Directory Structure

```
WinViber/
├── src/
│   ├── assets/
│   ├── components/
│   │   ├── components/
│   │   │   └── ResizableSidebar.tsx
│   │   ├── note/
│   │   │   ├── MarkdownEditorView.tsx
│   │   │   └── ...
│   │   ├── notification/
│   │   │   └── ...
│   │   ├── settings/
│   │   │   └── ...
│   │   ├── sidebar/
│   │   │   ├── TerminalListView.tsx
│   │   │   └── FavoritesView.tsx
│   │   └── terminal/
│   │       ├── TerminalPane.tsx
│   │       └── SplitView.tsx
│   ├── hooks/
│   ├── pages/
│   │   └── MainPage.tsx
│   ├── services/
│   │   └── themeManager.ts
│   ├── store/
│   │   └── useAppStore.ts
│   ├── styles/
│   ├── main.tsx
│   └── App.tsx
├── src-tauri/
│   ├── build.rs
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── src/
│       ├── core/
│       │   ├── logger.rs
│       │   └── parser.rs
│       ├── domain/
│       │   ├── models.rs
│       │   └── services/
│       │       ├── favorites_manager.rs
│       │       ├── note_manager.rs
│       │       ├── session_manager.rs
│       │       └── theme_manager.rs
│       ├── terminal/
│       │   ├── pty.rs
│       │   └── terminal_controller.rs
│       └── main.rs
└── ...
```

---

## Step 2: Core Data Models (Rust)

Defined in `src-tauri/src/domain/models.rs`. These structs will be serialized and sent to the frontend.

```rust
use serde::{Serialize, Deserialize};
use ts_rs::TS; // For generating TypeScript types from Rust

#[derive(Serialize, Deserialize, Clone, Debug, TS)]
#[ts(export)]
pub enum SessionStatus {
    Idle,
    Running,
    WaitingForInput,
    Terminated,
}

#[derive(Serialize, Deserialize, Clone, Debug, TS)]
#[ts(export)]
pub struct TerminalSession {
    pub id: String,
    pub name: String,
    pub working_directory: String,
    pub status: SessionStatus,
    pub alias: Option<String>,
    pub is_locked: bool,
    pub has_unread_notification: bool,
    pub last_activity: u64, // Timestamp
    #[serde(skip)]
    pub pty_id: Option<u32>,
}
```

---

## Step 3: Backend State & Commands (Rust)

Manage the application's state in a `Mutex` protected struct and expose it to Tauri.

```rust
// In src-tauri/src/main.rs

use std::sync::Mutex;

pub struct AppState {
    pub session_manager: Mutex<SessionManager>,
    pub theme_manager: Mutex<ThemeManager>,
    // ... other managers
}

fn main() {
    let app_state = AppState {
        session_manager: Mutex::new(SessionManager::new()),
        // ...
    };

    tauri::Builder::default()
        .manage(app_state)
        .invoke_handler(tauri::generate_handler![
            create_session,
            close_session,
            send_input_to_pty,
            // ... other commands
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

#[tauri::command]
fn create_session(state: tauri::State<AppState>, name: String, working_dir: String) -> TerminalSession {
    let mut manager = state.session_manager.lock().unwrap();
    // Logic to create a new session and spawn a PTY
    // ...
}
```

---

## Step 4: Terminal PTY Management (Rust)

Use a PTY management library or a custom implementation to spawn and control shell processes.

```rust
// In src-tauri/src/terminal/pty.rs

// This module will be responsible for:
// - Spawning a pseudo-terminal (e.g., using `portable-pty`).
// - Creating a reader thread that listens for PTY output and emits it as a Tauri event to the frontend.
// - Providing a writer function (exposed as a tauri::command) to send input from the frontend to the PTY.

// Example of emitting an event
// window.emit("pty-output", PtyOutput { pty_id, data });
```

---

## Step 5: Frontend State Management (React/Zustand)

Manage the application state on the frontend using a store like Zustand.

```typescript
// In src/store/useAppStore.ts
import create from 'zustand';
import { TerminalSession } from '../types'; // Generated by ts-rs

interface AppState {
  sessions: TerminalSession[];
  selectedSessionId: string | null;
  // ... other state
  createSession: (name: string, workingDir: string) => Promise<void>;
}

export const useAppStore = create<AppState>((set, get) => ({
  sessions: [],
  selectedSessionId: null,
  createSession: async (name, workingDir) => {
    const newSession = await invoke<TerminalSession>('create_session', { name, workingDir });
    set(state => ({ sessions: [...state.sessions, newSession] }));
  },
  // ...
}));
```

---

## Step 6: Terminal UI (React)

Use `xterm-react` to display the terminal and connect it to the backend via Tauri events.

```tsx
// In src/components/terminal/TerminalPane.tsx
import React, { useEffect } from 'react';
import { XTerm } from 'xterm-react';
import { listen } from '@tauri-apps/api/event';
import { invoke } from '@tauri-apps/api/tauri';

const TerminalPane = ({ sessionId, ptyId }) => {
  const xtermRef = React.useRef(null);

  useEffect(() => {
    const unlisten = listen(`pty-output:${ptyId}`, (event) => {
      xtermRef.current?.terminal.write(event.payload.data);
    });

    return () => {
      unlisten.then(f => f());
    };
  }, [ptyId]);

  const onData = (data: string) => {
    invoke('send_input_to_pty', { ptyId, data });
  };

  return <XTerm ref={xtermRef} onData={onData} />;
};
```

---

## Step 7: And so on...

The rest of the features would be implemented by combining the Rust backend and React frontend:

*   **Split Panes:** The split view logic would be managed in the React frontend, controlling the layout of `TerminalPane` components.
*   **Sidebar & Favorites:** The list of sessions and favorites would be rendered in React, with data fetched from the Rust backend.
*   **Settings:** Settings UI would be built in React, and changes would be sent to the Rust backend via commands to be persisted.
*   **Notifications:** The Rust backend would detect patterns in the PTY output and emit events to the frontend, which would then display the notifications.
*   **Markdown Notes:** A React component with a `textarea` for editing and `react-markdown` for previewing. The content would be saved and loaded via commands to the Rust backend.

This approach combines the performance and security of Rust for the backend with the rich UI ecosystem of React for the frontend, creating a powerful and cross-platform application.
